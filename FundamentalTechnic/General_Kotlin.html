<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>AttiTech-Software</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="/assets/css/main.css" />
		<noscript><link rel="stylesheet" href="/assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="Collections.html" class="logo">Refresh</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="/index.html">Main/Project Page</a></li>
							<li class="active"><a href="/generic.html">fundamental software</a></li>
							<li><a href="/information.html">information</a></li>
							<li><a href="/elements.html">Template</a></li>
						</ul>
						<ul class="icons">
	     <!-- 		        <li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
							<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>  -->
							<li><a href="https://www.linkedin.com/in/atilla-aydemir" target="_blank" class="icon brands fa-linkedin"><span class="label">Linkedin</span></a></li>
							<li><a href="https://github.com/aliatillaydemir" target="_blank" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
				


		<p>
            COMPANION OBJECT---------------------------------------------------------
            
            kotlin'de static properties ve static fonksiyonlar oluÅŸmasÄ±na izin verilmez.
            Java'da verilirdi. Bunun iÃ§in "Companion Object" kavramÄ± kullanÄ±lÄ±r.
            Companion Object iÃ§erisinde sÄ±nÄ±fta static olmasÄ±nÄ± istediÄŸimiz Constants,
            Properties, Functions tanÄ±mlayÄ±p rahatÃ§a kullanabiliriz.
            
            class Foo {
            
                public static Foo instance;
                public Foo() {
                    instance = this;
                }
            
            }
            
            -javada bu ÅŸekilde olan metod, kotlinde ÅŸu ÅŸekilde tanÄ±mlanÄ±r:
            
            class Foo {
            
                companion object {
                    lateinit var instance: Foo
                }
            
                init {
                    instance = this
                }
            
            }
            
            
            
            Classâ€™Ä± tekil(singleton) halde kullanabilmeyi saÄŸlamak iÃ§in companion
            object'i kullanÄ±rÄ±z.
            
            class Car(val horsepowers: Int) {
                companion object Factory {
                    val cars = mutableListOf<Car>()
            fun makeCar(horsepowers: Int): Car {
                        val car = Car(horsepowers)
                        cars.add(car)
                        return car
                    }
                }
            }
            
            Companion Object tek bir nesnedir ve Ã¼yelerine, iÃ§erdiÄŸi sÄ±nÄ±fÄ±n adÄ± 
            aracÄ±lÄ±ÄŸÄ±yla doÄŸrudan eriÅŸebiliyoruz. 
            
            val car = Car.makeCar(150)
            println(Car.Factory.cars.size)
            
            
            KÄ±saca Companion Objectâ€™i ÅŸu ÅŸekilde aklÄ±mÄ±za kazÄ±yabiliriz :
            
            Companion Object iÃ§inde tanÄ±mlÄ± olan nesneler baÅŸka programlama dillerindeki 
            (Java, C#) statik Ã¼yelere benzemektedir. AslÄ±nda Companion Object Ã§alÄ±ÅŸma 
            zamanÄ±nda gerÃ§ek nesnelerin Ã¼yeleridir ve bu nedenle bir Interfaceâ€™i 
            realized ederken bile kullanabiliyoruz.
            
            ----------------------------------------------------------------------------
            
            -> coroutineler kullanÄ±lacaÄŸÄ± zaman suspend fonksiyon kullanÄ±lÄ±r.
            -> ya da Scope.launch{} ile courutine scop'u oluÅŸturulup kodlar yazÄ±albilir.
            
            -------------------------------------------------------------------------
            
            state'ler deÄŸiÅŸiklik olduÄŸunda recompose iÃ§in gereklidir.
            
            -------------------------------------------------------------------------
            
            Flows -> livedata yerine kullanÄ±lÄ±yor.
            
            Coroutinler iÃ§inde Ã§alÄ±ÅŸÄ±yorlar. multiple deÄŸer emit'leyebilen(yayabilen)
            yapÄ±lardÄ±r. suspend'de tek dÃ¶ndÃ¼rebiliyoruz. veri tabanÄ±ndan canlÄ± gÃ¼ncelle-
            meler alÄ±p kullanabiliyoruz Ã¶rneÄŸin. javada yok, kotlinde var.
            
            retrofitle veri Ã§ekerken flow kullanÄ±labilir.
            
            livedata-flow farkÄ± ne?
            hemen hemen aynÄ± eÅŸyleri yapabiliyoruz ama flow biraz daha kullanÄ±m alanÄ± 
            geniÅŸ.
            
            flow operatÃ¶rler gibi...
            
            flow operatÃ¶rleri: map, filter, collect...
            https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/
            
            flowlarÄ±n tÃ¼rleri vardÄ±r.
            stateflow, sharedflow gibi...
            
            stateflow da bir sharedflowdur. sharedflowu alÄ±p kendimiz konfigÃ¼re ederiz.
            bÃ¶yle bir yapÄ±dÄ±r. bÃ¶yle bir ÅŸeye gerek yoksa stateflow ya da flow kullanÄ±la
            bilir.sharedflow kullanÄ±lacaksa inital bir deÄŸer verilmeldir.
            
            https://developer.android.com/kotlin/flow/stateflow-and-sharedflow
            
            
            -StateFlow, uygulamanÄ±z arka plandayken aktif kalacaktÄ±r, ancak kÃ¼Ã§Ã¼k bir 
            kurulumla LiveData'yÄ± StateFlow olarak yapabilirsiniz.
            
            -stateflow initial deÄŸerinin olmasÄ±na ihtiyaÃ§ duyar, live data ise 
            duymaz, opsiyoneldir.
            
            -eÄŸer bir initial(yani baÅŸlangÄ±Ã§) deÄŸeri varsa stateflow kullanmak daha 
            doÄŸrudur.
            
            -Stateflow ile Flow operatÃ¶rlerini kullanabilirsiniz ve bu LiveData ile 
            yapamayacaÄŸÄ±nÄ±z bir ÅŸeydir, LiveData'yÄ± Flow ile kullanmak istiyorsanÄ±z 
            daha fazlasÄ±na ihtiyacÄ±nÄ±z vardÄ±r.
            
            -------------------------------------------------------------------
            
            init{} metodu classÄ±n Ã¶zelliklerini alÄ±r(contructor gibi ama biraz farklÄ±).
            
            init bloÄŸu, primary constructor'dan hemen sonra yÃ¼rÃ¼tÃ¼lÃ¼r.
            initilazer bloklarÄ± etkin bir ÅŸekilde primary constructor'Ä±n bir parÃ§asÄ± 
            haline gelir. constructor secondary constructor'dÄ±r. primary constructor'a 
            delegasyon, 
            secondary constructor bir kurucunun ilk ifadesi olarak gerÃ§ekleÅŸir, bu 
            nedenle tÃ¼m baÅŸlatÄ±cÄ± bloklarÄ±ndaki kod, ikincil kurucu gÃ¶vdesinden Ã¶nce 
            yÃ¼rÃ¼tÃ¼lÃ¼r. 
            
            class Sample(private var s : String) {
                constructor(t: String, u: String) : this(t) {
                    this.s += u
                }
                init {
                    s += "B"
                }
            }
            
            
            Sample("T","U")
            
            Ã§Ä±ktÄ±: "TBU". Ã¶nce init, sonra constructor Ã§aÄŸÄ±rÄ±ldÄ±, aralarÄ±dnaki fark bu.
            T primary constructor(gÃ¶rmÃ¼yoruz) olduÄŸu iÃ§in en Ã¶nce o Ã§aÄŸÄ±rÄ±ldÄ±.
            
            https://www.geeksforgeeks.org/how-to-initialize-constructor-in-kotlin/
            
            
            -> bir classta birden fazla init bloÄŸu kullanabiliriz ama tek bir tane 
            kullanÄ±larsa daha iyi olur.
            
            ---------------------------------------------------------------------
            
            jetpack'daki lazyColumn kotlin ve javadaki recyclerView'dÄ±r.
            
            ----------------------------------------------------------------------
            
            compose'da side effects:
            
            uygulamanÄ±n state'inde deÄŸiÅŸiklik yapan ama aynÄ± zamanda composoble 
            scopeunun dÄ±ÅŸÄ±nda olan ÅŸeyler. bÃ¶yle bir durumda loopa girme gibi hatalar 
            olabiliyor.recomposition'a yok aÃ§arak, sÃ¼rekli baÅŸtan aÃ§ma durumunda buglar
            meydana gelir.
            
            sorunu Ã§Ã¶zmek iÃ§in LaunchedEffect kullanÄ±labilir. launchEffect sayesinde
            sadece bir defa istek gÃ¶nderildiÄŸini anlar ve bÃ¶yle arkada sÃ¼rekli istek 
            gÃ¶nderme, yani loop durumu meydana gelmez.
            
            LaunchedEffect(key1 = Unit){ //this: CoroutineScope
            bla bla...
            }
            
            produceState de bu sorunu Ã§Ã¶zer.
            
            produceState non-compose state'leri compose statelere Ã§evirir.
            
            val x = produceState<T>(initialValue = ""){ //this: ProduceState
            
            value = x bla bla...
            
            }
            
            
            DisposableEffect -> callbacklerle Ã¶nceki verileri kaldÄ±rma gibi iÅŸler yapar.
            bÃ¶ylelikle bahsedilen looplardan kurtulmuÅŸ olunur. 
            
            bu effectleri ele alma biÃ§imine effect handlers denir.
            
            --------------------------------------------------------------------------
            
            coroutine:
            
            Bir aÄŸ isteÄŸi attÄ±ÄŸÄ±mÄ±zda, local databaseden bir veri isteÄŸi yaptÄ±ÄŸÄ±mÄ±zda 
            veya daha genel olarak threadde uzun sÃ¼recek bir iÅŸlem yaptÄ±ÄŸÄ±mÄ±zda 
            imdadÄ±mÄ±za main threadi kitlememek ve kesintisiz akÄ±ÅŸÄ± kesmemek iÃ§in 
            coroutineler yetiÅŸiyor. Coroutinesleri threadde yapÄ±lan iÅŸlemin yapÄ±ldÄ±ÄŸÄ± 
            iÅŸ parÃ§acÄ±klarÄ± olarak dÃ¼ÅŸÃ¼nebiliriz.Genel olarak Lightweight Thread olarak 
            tanÄ±mlanÄ±yor. Bu konuda ÅŸuraya Ã¶zellikle vurgu yapmak istiyorum; Threadlere 
            benzer olmalarÄ±na raÄŸmen coroutinesleri kullanarak yeni bir threadde iÅŸ 
            yapmÄ±ÅŸ olmuyoruz. Zaten coroutineslerin bu kadar popÃ¼ler yapanda o. Ã‡Ã¼nkÃ¼ 
            yeni bir thread aÃ§mak Ã§ok maliyetli bir iÅŸlem. Out of memory hatasÄ± 
            almamÄ±za yol aÃ§abilir. Fakat coroutinesler threadlere gÃ¶re Ã§ok daha light 
            yapÄ±lar olduÄŸu iÃ§in daha az enerji harcayarak daha Ã§ok iÅŸ yaparlar.
            Yani Mevcut threadi bloklamadan askÄ±ya alÄ±nma iÅŸlevini saÄŸlarlar.
            
            suspend 
            
            Suspend Fonksiyonlar, normal bir fonksiyon yazmak gibidirler. 
            Tek farkÄ± sadece suspend keywordu getirilerek baÅŸlatÄ±rlar. Ä°Ã§erisinde 
            coroutines Ã§alÄ±ÅŸtÄ±rÄ±labilen fonksiyonlardÄ±r. Ä°stediÄŸimiz zaman durdurup,
            devam ettirip ve bitirebiliriz. Burada dikkat edilmesi gereken nokta 
            suspend fonksiyonlarÄ± ya bir suspend fonksiyon iÃ§erisinden veya coroutine 
            iÃ§erisinden Ã§aÄŸÄ±rabiliriz.
            
            suspend fun introduceYourself(){
                delay(2000)
                coroutineScope {
                    launch {
                        println("Merhaba ben suspend fonksiyonum.")
                    }
                }
            }
            
            
            Coroutine Dispatchers
            
            Coroutinelerimizi farklÄ± threadlerde Ã§alÄ±ÅŸtÄ±rmayÄ± saÄŸlar. YapacaÄŸÄ±mÄ±z 
            iÅŸlemin niteliÄŸine gÃ¶re dispatchersla hangi threadde olacaÄŸÄ±nÄ± belirteceÄŸiz.
            
            Dispatchers.Default : CPU kullanÄ±mÄ±n yoÄŸun olduÄŸu iÅŸlerde kullanÄ±lÄ±r.
            Ã–rneÄŸin gÃ¶rÃ¼ntÃ¼ iÅŸleme gibi ya da Ã§ok uzun bir dizinin iÃ§inden bir 
            filtreleme yapmak gibi iÅŸlerde kullanÄ±lÄ±r.
            
            Dispatchers.IO : Networking iÅŸlemlerinde kullanÄ±lÄ±r. Ã–rneÄŸin internetten bir
            veri Ã§ekmek veya databaseden veri almak gibi iÅŸlemlerde kullanÄ±lÄ±r.
            
            Dispatchers.Main : UI ile ilgili yaptÄ±ÄŸÄ±mÄ±z iÅŸlemler iÃ§in kullanÄ±lÄ±r. 
            Ã–rneÄŸin IOâ€™da yaptÄ±ÄŸÄ±mÄ±z bir iÅŸi mainle gÃ¶sterebiliriz. Ä°nternetten veri 
            Ã§ekerekn IOâ€™yu, bu veriyi kullanÄ±cÄ±ya UIâ€™da gÃ¶sterirken Mainâ€™i 
            kullanabiliriz.
            
            ----------------------------------------------------------------------------
            
            Sealed Class(mÃ¼hÃ¼rlÃ¼ sÄ±nÄ±flar)
            
            -tÃ¼retilemezler(Ã§Ã¼nkÃ¼ soyutlardÄ±r). 
            -Enum classlarÄ±n daha geliÅŸmiÅŸ halleridir
            
            Nesneye dayalÄ± programlama yaklaÅŸÄ±mÄ±nda kalÄ±tÄ±m (inheritence) Ã¶zelliÄŸi 
            sayesinde bir sÄ±nÄ±ftan baÅŸka sÄ±nÄ±flar tÃ¼retilebilir ve bu sÄ±nÄ±flara yeni 
            Ã¶zellikler eklenerek daha zengin ve kullanÄ±ÅŸlÄ± sÄ±nÄ±flar yaratÄ±labilir. 
            Ancak bazÄ± durumlarda sÄ±nÄ±flardan tÃ¼retme yapÄ±lmasÄ± istenmez. Bu durumda 
            sÄ±nÄ±f tanÄ±mlamasÄ±nÄ±n baÅŸÄ±na mÃ¼hÃ¼rlÃ¼ (sealed) kelimesi getirilir. Bu sayede 
            sabit Ã¶zellikler ve metotlara sahip bir sÄ±nÄ±f elde edilir. MÃ¼hÃ¼rlÃ¼ 
            sÄ±nÄ±f (sealed class) hiÃ§bir sÄ±nÄ±fÄ±n kendisinden tÃ¼retilemeyeceÄŸini ifade 
            eder.
            
            TÃ¼reyen sÄ±nÄ±fÄ±n anlamsÄ±z olmasÄ±nÄ±n engellenmesi, bazÄ± Ã¼yelerin gÃ¼venliÄŸinin 
            saÄŸlanmasÄ± ya da Ã¼yeleri statik olan sÄ±nÄ±flarÄ±n korunmasÄ± amacÄ±yla 
            tÃ¼retilme yapÄ±lmamasÄ± iÃ§in sealed (mÃ¼hÃ¼rlÃ¼) anahtar kelimesi kullanÄ±larak 
            mÃ¼hÃ¼rlÃ¼ sÄ±nÄ±flar (sealed class) oluÅŸturulur. 
            
            Enumlarda parametresiz Ã§aÄŸÄ±rma gerÃ§ekleÅŸemez.  Enumlar tek tÃ¼r veri 
            tipi tutabilir. AyrÄ±ca Enumlarda parametre varsa tÃ¼m deÄŸerler oluÅŸturma 
            anÄ±nda set edilmeli, bu durum da kapsÃ¼lleme yaparken ihtiyacÄ±mÄ±z dÄ±ÅŸÄ±ndaki 
            alanlarÄ±n set edilmesini zorunlu kÄ±lÄ±yor. bu da clean code aÃ§Ä±sÄ±ndan doÄŸru
            deÄŸil. Sealed class'ta ise bu bir problem olmaktan Ã§Ä±kÄ±yor.
            
            -Ã‡Ã¼nkÃ¼ Enumlar tek bir deÄŸiÅŸken tipi tutabiliyorken Sealed SÄ±nÄ±flar her 
            bir state iÃ§in farklÄ± deÄŸiÅŸken tipi tutabilirler.
            
            ---------------------------------------------------------------------------
            
            Data Class
            
            Data Classâ€™lar verileri depolamak iÃ§in kullanÄ±lan Ã¶zel sÄ±nÄ±flardÄ±r ve 
            data anahtar sÃ¶zcÃ¼ÄŸÃ¼yle tanÄ±mlanÄ±rlar. Data Classâ€™larda getter ve setter 
            metotlarÄ±, hashCode(), equals(), toString(), copy() metotlarÄ±nÄ± 
            kendiliÄŸinden Ã¼retir.
            
            Enum Class
            
            KullanÄ±cÄ± tarafÄ±ndan tanÄ±mlanan veri kÃ¼meleri iÃ§in enum classâ€˜lar 
            kullanÄ±labilir
            
            Singleton Class(object ya da companion object)
            
            Singleton class singleton nesnesi olarak da adlandÄ±rÄ±labilir. 
            Bir sÄ±nÄ±ftan "yalnÄ±zca bir Ã¶rnek" oluÅŸturmak ve bunu bu haliyle her yerde 
            kullanmak istediÄŸimizde bu yolu izleyebiliriz. Class anahtar sÃ¶zcÃ¼ÄŸÃ¼ yerine 
            object anahtar sÃ¶zcÃ¼ÄŸÃ¼nÃ¼ kullanÄ±rÄ±z.
            
            object Calculate {
                fun multiplying(number1: Int, number2: Int): Int {
                    return number1 * number2
                }
            }
            
            ---------------------------------------------------------------------------
            
            DataStore
            
            Shared Preferences(deprecated ama androidx kÃ¼tÃ¼phanesiyle kullanÄ±labilir,
            android documanda geleneksel olarak hala Ã¶neriliyor.) yerine kullanÄ±labilir. 2 adet dataStore var. Preference DataStore ve 
            proto dataStore. bu ikisi Ã§ok benzer ama ufak farklÄ±lÄ±klarÄ± var.
            
            
            preference datastore -> proto gibi type safe deÄŸildir.
            
            
            proto datastore -> type safe'dir. biraz komplekstir. 
            setup kurmak ve basit verileri kaydetmek iÃ§in model kurmak gerekir. 
            bu yÃ¼zden bunu kullanmak(type safe'e ihtiyaÃ§ varsa Ã¶zellikle) yerine room 
            kullanmak daha iyi bir fikir olabilir.
            
            
            ----------------------------------------------------------------------------
            
            Type Safety
            
            Type-Safety, â€œtÃ¼r gÃ¼venliÄŸiâ€ olarak Ã§evirilebilir. yazÄ±lÄ±mda kullanÄ±lan bir 
            terimdir. TÃ¼r gÃ¼venliÄŸi, derleyici derleme sÄ±rasÄ±nda tÃ¼rleri doÄŸrulayacak 
            ve biz bir deÄŸiÅŸkene yanlÄ±ÅŸ tÃ¼r atamayÄ± denersek hata vereceÄŸi anlamÄ±na 
            gelir. Ã–rneÄŸin C#, C++, Java type-safe bir dildir. Javaâ€™da bir deÄŸiÅŸken 
            tanÄ±mlamak istediÄŸimizde o deÄŸiÅŸkenin hangi veri tipinde bir deÄŸiÅŸken 
            olduÄŸunu belirtmek zorundayÄ±z. Mesela  PHP, JavaScript ve diÄŸer dynamic 
            scripting dillerinde bu durum sÃ¶z konusu deÄŸildir. JavaScriptâ€™de bir 
            deÄŸiÅŸken tanÄ±mladÄ±ÄŸÄ±mÄ±zda bu deÄŸiÅŸkenlere bir tip atamak zorunda deÄŸiliz, 
            yani bir seferinde o deÄŸiÅŸkene sayÄ± atayÄ±p sonrasÄ±nda aynÄ± deÄŸiÅŸkene 
            karakter atayabiliriz. 
            
            
            ----------------------------------------------------------------------------
            
            instance
            
            KÄ±saca nesne denebilir.
            Bir evin tasarÄ±m planÄ±,bir sÄ±nÄ±fÄ± ifade etsin(Class). Bu plandan inÅŸa edilen
            tÃ¼m evler, bu sÄ±nÄ±fÄ±n nesneleridir(Object). Ve her bir ev de birer 
            Ã¶rnektir(Instance).
            
            ----------------------------------------------------------------------------
            
            Dependency Injection
            
            -dagger/hilt
            
            aslÄ±nda bir tÃ¼r design pattern'dÄ±r. bu patternin amacÄ± verilen bir objenin 
            variable'larÄ±nÄ±n instance edilmesidir.
            
            
            -Hilt kullanan tÃ¼m uygulamalar, @HiltAndroidApp annotasyonu iÃ§eren bir 
            Application sÄ±nÄ±fÄ± iÃ§ermelidir.
            
            @HiltAndroidApp
            class ExampleApplication : Application() { ... }
            
            Bu oluÅŸturulan Hilt bileÅŸeni, Application nesnesinin yaÅŸam dÃ¶ngÃ¼sÃ¼ne eklenir 
            ve ona baÄŸÄ±mlÄ±lÄ±klar saÄŸlar. Ek olarak, uygulamanÄ±n ana bileÅŸenidir; bu, 
            diÄŸer bileÅŸenlerin saÄŸladÄ±ÄŸÄ± baÄŸÄ±mlÄ±lÄ±klara eriÅŸebileceÄŸi anlamÄ±na gelir.
            
            
            Android sÄ±nÄ±flarÄ±na baÄŸÄ±mlÄ±lÄ±klarÄ± enjekte etme:
            
            -Hilt, Application sÄ±nÄ±fÄ±nÄ±zda ayarlandÄ±ÄŸÄ±nda ve uygulama dÃ¼zeyinde bir 
            bileÅŸen kullanÄ±labilir olduÄŸunda Hilt, @AndroidEntryPoint ek annotasyonuna
            sahip diÄŸer Android sÄ±nÄ±flarÄ±na baÄŸÄ±mlÄ±lÄ±klar saÄŸlayabilir:
            
            @AndroidEntryPoint
            class ExampleActivity : AppCompatActivity() { ... }
            
            Hilt aÅŸaÄŸÄ±daki Android sÄ±nÄ±flarÄ±nÄ± desteklemektedir:
            
            Application (by using @HiltAndroidApp)
            ViewModel (by using @HiltViewModel)
            Activity
            Fragment
            View
            Service
            BroadcastReceiver
            
            @AndroidEntryPoint ile bir Android sÄ±nÄ±fÄ±na aÃ§Ä±klama eklerseniz, buna baÄŸlÄ± 
            olan Android sÄ±nÄ±flarÄ±na da aÃ§Ä±klama eklemeniz gerekir. Ã–rneÄŸin, bir parÃ§aya 
            aÃ§Ä±klama eklerseniz, o parÃ§ayÄ± kullandÄ±ÄŸÄ±nÄ±z tÃ¼m aktivitelere de de aÃ§Ä±klama 
            eklemelisiniz.
            
            -Bir bileÅŸenden baÄŸÄ±mlÄ±lÄ±klar elde etmek iÃ§in, alan(field) enjeksiyonu 
            gerÃ§ekleÅŸtirmek iÃ§in @Inject ek aÃ§Ä±klamasÄ±nÄ± kullanÄ±n:
            
            @AndroidEntryPoint
            class ExampleActivity : AppCompatActivity() {
            
              @Inject lateinit var analytics: AnalyticsAdapter
              ...
            }
            
            Hilt'in enjekte ettiÄŸi sÄ±nÄ±flar, enjeksiyon kullanan baÅŸka temel 
            sÄ±nÄ±flara da sahip olabilir. Bu sÄ±nÄ±flar, soyutlarsa @AndroidEntryPoint 
            ek aÃ§Ä±klamasÄ±na ihtiyaÃ§ duymazlar.
            
            
            Hilt baÄŸlamlarÄ± tanÄ±mlama(bindings):
            
            Alan(field) enjeksiyonunu gerÃ§ekleÅŸtirmek iÃ§in Hilt'in ilgili bileÅŸenden 
            gerekli baÄŸÄ±mlÄ±lÄ±klarÄ±n Ã¶rneklerini nasÄ±l saÄŸlayacaÄŸÄ±nÄ± bilmesi gerekir. 
            binding, bir tÃ¼rÃ¼n Ã¶rneklerini bir baÄŸÄ±mlÄ±lÄ±k olarak saÄŸlamak iÃ§in gerekli 
            bilgileri iÃ§erir. Hilt'e baÄŸlama bilgisi saÄŸlamanÄ±n bir yolu, constructor 
            enjeksiyonudur. Hilt'e o sÄ±nÄ±fÄ±n Ã¶rneklerini nasÄ±l saÄŸlayacaÄŸÄ±nÄ± sÃ¶ylemek 
            iÃ§in bir sÄ±nÄ±fÄ±n yapÄ±cÄ±sÄ±nda @Inject ek aÃ§Ä±klamasÄ± kullanÄ±lÄ±r.
            
            class AnalyticsAdapter @Inject constructor(
              private val service: AnalyticsService
            ) { ... }
            
            
            
            
            Hilt modÃ¼ller:
            
            Bazen belli sebeplerden dolayÄ± constructor injected yapamayÄ±z. Mesela bir 
            interface'e constructor enjekte edemeyiz. ya da dÄ±ÅŸarÄ±dan bir kÃ¼tÃ¼phaneye
            constructor ekleyemeyiz. bÃ¶yle durumlarda  hilt modÃ¼lleri kullanÄ±lÄ±r.
            
            Hilt modÃ¼lÃ¼, @Module ile aÃ§Ä±klamalÄ± bir sÄ±nÄ±ftÄ±r. Bir Dagger modÃ¼lÃ¼ gibi, 
            Hilt'e belirli tÃ¼rlerin Ã¶rneklerinin nasÄ±l saÄŸlanacaÄŸÄ±nÄ± bildirir. Dagger 
            modÃ¼llerinden farklÄ± olarak, Hilt'e her modÃ¼lÃ¼n hangi Android sÄ±nÄ±fÄ±nda 
            kullanÄ±lacaÄŸÄ±nÄ± veya kurulacaÄŸÄ±nÄ± sÃ¶ylemek iÃ§in Hilt modÃ¼llerine @InstallIn 
            ile aÃ§Ä±klama eklemelisiniz.
            
            Hilt modÃ¼llerinde saÄŸladÄ±ÄŸÄ±nÄ±z baÄŸÄ±mlÄ±lÄ±klar, Hilt modÃ¼lÃ¼nÃ¼ kurduÄŸunuz 
            Android sÄ±nÄ±fÄ± ile iliÅŸkilendirilmiÅŸ oluÅŸturulan tÃ¼m bileÅŸenlerden 
            ulaÅŸÄ±labilir
            
            Inject interface instances with @Binds:
            
            sÄ±nÄ±fÄ±nÄ±z bir arayÃ¼zse, onu constructor-enjekte edemezsiniz. Bunun yerine, 
            Hilt modÃ¼lÃ¼ iÃ§inde @Binds ile aÃ§Ä±klamalÄ± soyut(abstract) bir iÅŸlev 
            oluÅŸturarak Hilt'e baÄŸlama bilgilerini saÄŸlayÄ±n.
            
            
            
            interface AnalyticsService {
              fun analyticsMethods()
            }
            
            // Constructor-injected, because Hilt needs to know how to
            // provide instances of AnalyticsServiceImpl, too.
            class AnalyticsServiceImpl @Inject constructor(
              ...
            ) : AnalyticsService { ... }
            
            @Module
            @InstallIn(ActivityComponent::class)
            abstract class AnalyticsModule {
            
              @Binds
              abstract fun bindAnalyticsService(
                analyticsServiceImpl: AnalyticsServiceImpl
              ): AnalyticsService
            }
            
            
            @Provides ile instancelarÄ± enjekte etme:
            Bir tÃ¼rÃ¼ contructor enjekte edemediÄŸiniz tek durum arayÃ¼zler deÄŸildir. 
            SÄ±nÄ±fÄ±n harici bir kitaplÄ±ktan retrofit, OkHttpClient veya Room veritabanlarÄ±
            gibi sÄ±nÄ±flar) geldiÄŸi iÃ§in sÄ±nÄ±fÄ±n sahibi deÄŸilseniz veya builder
            modeliyle Ã¶rneklerin oluÅŸturulmasÄ± gerekiyorsa, constructor ekleme de mÃ¼mkÃ¼n
            deÄŸildir. Ã–nceki Ã¶rneÄŸi dÃ¼ÅŸÃ¼nÃ¼n. AnalyticsService sÄ±nÄ±fÄ±na doÄŸrudan sahip 
            deÄŸilseniz, Hilt modÃ¼lÃ¼ iÃ§inde bir iÅŸlev oluÅŸturarak ve bu iÅŸleve 
            @Provides ile aÃ§Ä±klama ekleyerek Hilt'e bu tÃ¼r Ã¶rneklerin nasÄ±l 
            saÄŸlanacaÄŸÄ±nÄ± sÃ¶yleyebilirsiniz.
            
            
            annotasyonlu fonksiyon Hilt'e aÅŸaÄŸÄ±daki bilgileri saÄŸlar:
            
            -fonksiyon return tÃ¼rÃ¼, Hilt'e fonksiyonun hangi tÃ¼rÃ¼n nesnelerini 
            saÄŸladÄ±ÄŸÄ±nÄ±(provide ettiÄŸini) sÃ¶yler.
            
            -fonksiyon parametreleri Hilt'e karÅŸÄ±lÄ±k gelen tÃ¼rÃ¼n baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± sÃ¶yler.
            
            -fonksiyon gÃ¶vdesi, Hilt'e ilgili tipte bir instancesÄ±n nasÄ±l saÄŸlanacaÄŸÄ±nÄ± 
            sÃ¶yler. Hilt, bu tÃ¼rden bir instance saÄŸlamasÄ± gerektiÄŸinde fonksiyon 
            gÃ¶vdesini yÃ¼rÃ¼tÃ¼r.
            
            
            @Module
            @InstallIn(ActivityComponent::class)
            object AnalyticsModule {
            
              @Provides
              fun provideAnalyticsService(
                // Potential dependencies of this type
              ): AnalyticsService {
                  return Retrofit.Builder()
                           .baseUrl("https://example.com")
                           .build()
                           .create(AnalyticsService::class.java)
              }
            }
            
            
            Hilt component	      ---       Injector for
            
            SingletonComponent	        Application
            ActivityRetainedComponent	N/A
            ViewModelComponent	        ViewModel
            ActivityComponent	        Activity
            FragmentComponent	        Fragment
            ViewComponent			View
            ViewWithFragmentComponent	View annotated with @WithFragmentBindings
            ServiceComponent		Service
            
            
            Component lifetimes
            
            Hilt, ilgili Android sÄ±nÄ±flarÄ±nÄ±n yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ takiben oluÅŸturulan 
            bileÅŸen sÄ±nÄ±flarÄ±nÄ±n instancelarÄ± otomatik olarak oluÅŸturur ve yok eder.
            
            
            Generated component	   Created at		     Destroyed at
            
            SingletonComponent	   Application#onCreate()    Application destroyed
            ActivityRetainedComponent  Activity#onCreate()	     Activity#onDestroy()
            ViewModelComponent	   ViewModel created	     ViewModel destroyed
            ActivityComponent	   Activity#onCreate()	     Activity#onDestroy()
            FragmentComponent	   Fragment#onAttach()	     Fragment#onDestroy()
            ViewComponent	           View#super()	             View destroyed
            ViewWithFragmentComponent  View#super()	             View destroyed
            ServiceComponent	   Service#onCreate()	     Service#onDestroy()
            
            
            
            https://developer.android.com/training/dependency-injection/hilt-android#kotlin
            
            ----------------------------------------------------------------------------
            
            
            Kotlin generics
            
            Jenerikler, derleme zamanÄ± tipi gÃ¼venliÄŸini kontrol ederken farklÄ± veri 
            tÃ¼rleri kullanÄ±larak eriÅŸilebilen sÄ±nÄ±flarÄ±, yÃ¶ntemleri ve Ã¶zellikleri 
            tanÄ±mlamamÄ±za izin veren gÃ¼Ã§lÃ¼ Ã¶zelliklerdir.
            
            Parametreli sÄ±nÄ±flar oluÅŸturma: 
            
            Genel bir tÃ¼r, tÃ¼rler Ã¼zerinde parametrelendirilen bir sÄ±nÄ±f veya yÃ¶ntemdir.
            Programda type parametresini belirtmek iÃ§in her zaman kÃ¶ÅŸeli parantez () 
            kullanÄ±rÄ±z.
            
            
            class MyClass<T>(text: T) {
                var name = text
            }
            
            BÃ¶yle bir sÄ±nÄ±fÄ±n bir instancesÄ±nÄ±/nesnesi oluÅŸturmak iÃ§in, tÃ¼r argÃ¼manlarÄ±nÄ±
            saÄŸlamamÄ±z(provide etmemiz) gerekir:
            
            val my : MyClass<String> = Myclass<String>("GeeksforGeeks")
            
            Parametreler constructor argÃ¼manlarÄ±ndan Ã§Ä±karÄ±labiliyorsa, tÃ¼r 
            argÃ¼manlarÄ±nÄ±n atlanmasÄ±na izin verilir:
            
            val my = MyClass("GeeksforGeeks") 
            
            Jenerik avantajlarÄ±: 
            
            â€“Type casting'den kaÃ§Ä±labilir. - Nesneyi type cast etmeye gerek yoktur. 
            -Type safety - generic, bir seferde yalnÄ±zca tek tip nesneye izin verir. 
            -Derleme zamanÄ± gÃ¼venliÄŸi - generic kod, Ã§alÄ±ÅŸtÄ±rma zamanÄ± hatasÄ±nÄ± Ã¶nlemek 
            iÃ§in parametreli tÃ¼r iÃ§in derleme zamanÄ±nda kontrol edilir.
            
            genericsiz kotlin:
            
            class Company (text: String) {
                var x = text
                init{
                    println(x)
                }
            }
            fun main(args: Array<String>){
                var name: Company = Company("GeeksforGeeks")
                var rank: Company = Company(12)// compile time error
            }
            
            hata mesajÄ±:
            Error:(10, 33) Kotlin: The integer literal does not conform to the expected type String
            
            
            generic kullanÄ±larak:
            
            class Company<T> (text : T){
                var x = text
                init{
                    println(x)
                }
            }
            fun main(args: Array<String>){
                var name: Company<String> = Company<String>("GeeksforGeeks")
                var rank: Company<Int> = Company<Int>(12)
            } 
            
            Ã§Ä±ktÄ±:
            
            GeeksforGeeks
            1234
            
            
            ----------------------------------------------------------------------------
            
            java ya da kotlinde app farklÄ± dil seÃ§eneklerine sahip olacaksa farklÄ± 
            strings.xml dosyalarÄ± aÃ§Ä±lÄ±r. strings.xml, strings.xml (de) gibi(almanca..).
            
            <resources>
            <string name = "hello_world">Hallo Welt</string>
            </resoruces>
            
            bu kadar. almanca olduÄŸu zaman almanca strings iÃ§erisindeki hallo_world 
            deÄŸiÅŸkeninin deÄŸeri Hallo Welt olacak. Bu yÃ¼zden yazÄ±larÄ± strings.xml'de
            tutmak lazÄ±m,Ã¶kÃ¼z gibi sÄ±nÄ±flarÄ±n iÃ§ine yazmamak lazÄ±m Ã§eviri ihtiyacÄ± varsa.
            
            AyrÄ±ca Ã¶rneÄŸin compose'da; 
            
            Text(text = stringResource(id = R.string.hello_world)) 
            
            yazarak yanda Ã§Ä±kan uyarÄ±ya tÄ±klayabilirsin. BÃ¶yle bir strings dosyasÄ± yok,
            yaratayÄ±m mÄ± diye sorar. Strings dosyasÄ±nÄ± kendin oluÅŸturup iÃ§ini doldurmana
            gerek yok.
            
            ----------------------------------------------------------------------------
            
            Dizi	vs    ArrayList
            
            1.)
            Dizi, dizi nesnesi oluÅŸturulduktan sonra uzunluÄŸu deÄŸiÅŸtirilemeyen sabit 
            uzunluklu bir veri yapÄ±sÄ±dÄ±r.	
            
            ArrayList doÄŸada dinamiktir, bu da gerektiÄŸinde bÃ¼yÃ¼mesi iÃ§in yeniden 
            boyutlandÄ±rÄ±labileceÄŸi anlamÄ±na gelir.
            
            2.)
            Bir dizinin boyutu program boyunca sabit kalÄ±r.	
            
            ArrayList'in boyutu yÃ¼ke ve kapasiteye baÄŸlÄ± olarak dinamik olarak 
            bÃ¼yÃ¼yebilir.
            
            3.)
            dizide Ã–ÄŸeleri depolamak iÃ§in atama iÅŸleci kullanÄ±r. 
            arraylistte Ã–ÄŸeleri eklemek iÃ§in add () Ã¶zelliÄŸini kullanÄ±r.
            
            4.)
            AynÄ± veya farklÄ± veri tÃ¼rÃ¼ndeki nesnelerin yanÄ± sÄ±ra ilkel Ã¶ÄŸeler iÃ§erebilir.
            ArrayList'te temel Ã¶ÄŸelere izin verilmez. YalnÄ±zca nesne tÃ¼rlerini iÃ§erebilir.
            
            5.)
            Diziler ve Jenerikler el ele gitmez. 
            ArrayList'te jeneriklere izin verilir.
            
            6.)
            Diziler Ã§ok boyutlu olabilir.	
            ArrayList tek boyutludur.
            
            7.)
            Ã–ÄŸelerin bitiÅŸik bellek konumlarÄ±nda depolandÄ±ÄŸÄ± yerel bir programlama 
            bileÅŸenidir.	
            Nesnelerin hiÃ§bir zaman bitiÅŸik yerlerde saklanmadÄ±ÄŸÄ± Java'nÄ±n koleksiyon 
            Ã§erÃ§evesinden bir sÄ±nÄ±ftÄ±r.
            
            8.)
            length deÄŸiÅŸkeni, Dizinin uzunluÄŸunu belirlemek iÃ§in kullanÄ±lÄ±r. 
            ArrayList Ã¶ÄŸesinin boyutunu belirlemek iÃ§in size () yÃ¶ntemi kullanÄ±lÄ±r.
            
            9.)
            Belirtilen Ã¶ÄŸeleri veya nesneleri depolamak iÃ§in ArrayList'ten daha az 
            bellek alÄ±r.	
            Nesneleri depolamak iÃ§in Diziden daha fazla bellek alÄ±r.
            
            9.)
            Dizi Ã¼zerinde yineleme yapmak, ArrayList Ã¼zerinden yinelemekten daha hÄ±zlÄ±dÄ±r
            ArrayList Ã¼zerinden yineleme, performans aÃ§Ä±sÄ±ndan Ã¶nemli Ã¶lÃ§Ã¼de yavaÅŸtÄ±r.
            
            ----------------------------------------------------------------------------
            
            ğŸ‘‰ ANR nedir?
            
            Android mÃ¼lakat sorularÄ± arasÄ±nda en Ã¶nemlisi de ANRâ€™nin ne olduÄŸu 
            Ã¼zerinedir. ANR (Application Not Responding), â€œUygulama YanÄ±t Vermiyorâ€ 
            anlamÄ±na gelen ve sistem tarafÄ±ndan gÃ¶sterilen bir dialogdur.
            Bir uygulama uzun bir sÃ¼re boyunca yanÄ±t vermediÄŸinde kullanÄ±cÄ±ya gÃ¶rÃ¼nen 
            bir iletiÅŸim kutusudur.
            
            
            ----------------------------------------------------------------------------
            
            ğŸ‘‰ Content Provider nedir?
            
            Content Provider, uygulamalarda kullanÄ±lan yerel verileri baÅŸka bir 
            uygulamanÄ±n kullanÄ±mÄ±na aÃ§Ä±lmasÄ± durumunda veriler Ã¼zerinde deÄŸiÅŸiklik 
            yapma Ã¼zerine kullanÄ±lan bir yapÄ±dÄ±r.
            
            Content proviverlar, verinin saklanma ve iletilme yÃ¶nteminden baÄŸÄ±msÄ±z olarak
            veriyi gÃ¼venli bir ÅŸekilde diÄŸer uygulamalara sunar. Content providerlar 
            vasÄ±tasÄ±yla uygulamalar veriye direkt eriÅŸim saÄŸlayabilirler. Ã–rneÄŸin; 
            Calendar, SMS, Contact APIâ€™larÄ± bu ÅŸekilde Ã§alÄ±ÅŸmaktadÄ±r.
            
            -----------------------------------------------------------------------------
            
            Android Lifecycle
            
            onCreate () : Activity oluÅŸturulur.
            
            onStart () : Bu geri Ã§aÄŸÄ±rma yÃ¶ntemi, activity kullanÄ±cÄ± tarafÄ±ndan gÃ¶rÃ¼nÃ¼r hale geldiÄŸinde Ã§aÄŸrÄ±lÄ±r.
            
            onResume () : Activity Ã¶n plandadÄ±r ve kullanÄ±cÄ± onunla etkileÅŸim kurabilir.
            
            onPause () : Activity, baÅŸka bir etkinlik tarafÄ±ndan kÄ±smen engellenmiÅŸtir. Ã–n plandaki diÄŸer etkinlik yarÄ± ÅŸeffaftÄ±r.
            
            onStop () : Activity tamamen gizlidir ve kullanÄ±cÄ± tarafÄ±ndan gÃ¶rÃ¼lmez.
            
            onDestroy () : Activity yok edilir ve bellekten kaldÄ±rÄ±lÄ±r.
            
            -----------------------------------------------------------------------------
            
            ğŸ‘‰ Androidâ€™in temel yapÄ± taÅŸlarÄ± nelerdir?
            
            Activity: Aktivity, Androidâ€™deki herhangi bir uygulamanÄ±n ekran temsilidir. 
            Her etkinliÄŸin, kullanÄ±cÄ± arayÃ¼zÃ¼nÃ¼zÃ¼ yerleÅŸtirebileceÄŸiniz bir dÃ¼zen dosyasÄ±
            vardÄ±r.
            
            Content Provider:  Ä°Ã§erik saÄŸlayÄ±cÄ±lar, uygulamalar arasÄ±nda veri paylaÅŸÄ±r.
            
            Service: KullanÄ±cÄ± ile etkileÅŸime girmeden uzun sÃ¼reli iÅŸlemleri 
            gerÃ§ekleÅŸtirmek iÃ§in arka planda Ã§alÄ±ÅŸan bir bileÅŸendir ve uygulama yok 
            edildiÄŸinde bile Ã§alÄ±ÅŸÄ±r.
            
            Broadcast: DiÄŸer uygulamalardan veya sistemin kendisinden gelen yayÄ±n 
            mesajlarÄ±na yanÄ±t verir. Bu mesajlar bazen olaylar veya niyetler olarak 
            adlandÄ±rÄ±lÄ±r.
            
            -----------------------------------------------------------------------------
            
            Android Mimarisi 4 temel bileÅŸenden oluÅŸur:
            
            Linux Kernel
            Libraries
            Android Framework
            Android Applications
            
            -----------------------------------------------------------------------------
            
            
            Android'te veri saklamak iÃ§in kaÃ§ yol vardÄ±r ? 
            
            5 yol vardÄ±r. Shared preferences, Internal Storage, Local cache, 
            External Storage, SQLite Database, Content Provider, Network Connection.
            
            -----------------------------------------------------------------------------
            
            SharedPreferences'e data yazarken commit() ve apply() methodlarÄ±nÄ±n 
            farkÄ± nedir? 
            
            commit() syncronous gerÃ§ekleÅŸirken apply() asyncronous gerÃ§ekleÅŸir. 
            Yani commit() Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda o iÅŸlemi hemen gerÃ§ekleÅŸtirir. apply() methodu 
            da arka planda gerÃ§ekleÅŸir.
            
            -----------------------------------------------------------------------------
            
            Fragmentlarda empty constructora ihtiyaÃ§ var mÄ±dÄ±r? Neden? 
            
            Fragment oluÅŸtururken empty constructor'a ihtiyaÃ§ vardÄ±r. BazÄ± durumlarda 
            (Screen rotation vs.) android frameworku fragmenti destroy edip tekrar 
            yaratÄ±r. Bu durumda framework tarafÄ±nda fragment'Ä±n empty constructor'Ä± 
            Ã§aÄŸrÄ±lÄ±r. EÄŸer parametreli bir constructor eklemediysek empty constructor 
            yaratmaya ihtiyaÃ§ yoktur Ã§Ã¼nkÃ¼ bu durumda java compiler empty constructor'u 
            kendi ekler. Fakat parametreli bir constructor tanÄ±mlarsak eÄŸer bunun 
            yanÄ±nda empty constructor tanÄ±mlamak zorundayÄ±z.
            
            Parametreli bir constructor tanÄ±mlayÄ±p empty constructor tanÄ±mlamazsak 
            uygulamamÄ±z Ã§alÄ±ÅŸmaz mÄ±? Ã‡alÄ±ÅŸÄ±r. Fakat rotation change vs. gibi android 
            frameworkÃ¼nÃ¼n fragmenti yok edip tekrar yarattÄ±ÄŸÄ± durumda 
            android.support.v4.app.Fragment$InstantiationException hatasÄ± alÄ±rsÄ±nÄ±z.
            
            -----------------------------------------------------------------------------
            
            KaÃ§ farklÄ± veri taÅŸÄ±ma yÃ¶ntemi vardÄ±r? Bunlardan en performanslÄ±sÄ± 
            hangisidir?
            
            Interface ile veri taÅŸÄ±ma
            Bundle veya Intent ile veri taÅŸÄ±ma
            Parcelable ve serializable ile veri taÅŸÄ±ma
            Uzak sunucu ile veri taÅŸÄ±ma
            Shared Preferences ile veri taÅŸÄ±ma
            Static keyword veya singleton ile veri taÅŸÄ±ma(Burada singletonâ€™Ä±n bir anti 
            patern olduÄŸunu mutlaka belirtin)
            on activity result ile activityler arasÄ± veri taÅŸÄ±ma
            
            En performanslÄ± Ã§alÄ±ÅŸan sorunun cevabÄ± primitive tipler iÃ§in Bundle veya 
            Intent, referans tipliler iÃ§in ise Parcelable ile veri taÅŸÄ±madÄ±r.
            
            -----------------------------------------------------------------------------
            
            Serialization ve deserialization nedir?
            
            Referans tipli bir classÄ±n nesnesinin bÃ¼tÃ¼n deÄŸiÅŸkenlerini ve constructor 
            ile beraber stringe Ã§evirme iÅŸlemine serialization denir. Daha sonra 
            stringten classa Ã§evirme iÅŸlemine de deserialization denir. Ek bilgi olarak 
            parcelable ile serialization aynÄ± iÅŸi yapÄ±yor fakat parcelable 10 kat daha 
            hÄ±zlÄ±dÄ±r. Sebebi ise serialization bir java kÃ¼tÃ¼phanesidir ve herhangi bir 
            web, masaÃ¼stÃ¼ projesinde kullanÄ±lÄ±r. Parcelable ise bir Android 
            kÃ¼tÃ¼phanesidir yani yalnÄ±zca Android projelerinde kullanÄ±lÄ±r. Son bir 
            toparlama olarak da ÅŸÃ¶yle bir bilgi vereyim, primitive tip taÅŸÄ±mak 
            istiyorsak en hÄ±zlÄ± veri taÅŸÄ±ma yÃ¶ntemi Intent veya Bundle , referans tipli 
            bir deÄŸiÅŸken taÅŸÄ±mak istiyorsak Parcelable iÅŸimizi gÃ¶recektir.
            
            -----------------------------------------------------------------------------
            
            Fragmentlar neden hep frame layouta ekleniyor?
            
            BilindiÄŸi Ã¼zere herhangi bir layouta da fragment eklenebilir ilk Ã¶nce bu 
            bilgiyi bilmekte fayda var. Neden hep frame layout sorusuna gelirsek, 
            yapÄ±sÄ± gereÄŸi layoutlarÄ±n iÃ§inde en az Ã¶zellik sunan layout, frame 
            layouttÄ±r ki zaten biz farklÄ± bir layout eklesek de onun Ã¶zelliklerini 
            kullanmayacaÄŸÄ±z. DiÄŸer layoutlara gÃ¶re daha az iÅŸlemci gÃ¼cÃ¼ harcar ve bu da 
            fragmentlarÄ±n frame layouta eklenmesinin nedenidir.
            
            -----------------------------------------------------------------------------
            
            Singleton Pattern nedir?
            
            Ä°sminden de anlaÅŸÄ±lacaÄŸÄ± Ã¼zere singleton tasarÄ±m deseni, hazÄ±rlayacaÄŸÄ±mÄ±z 
            sÄ±nÄ±ftan sadece bir Ã¶rneÄŸinin oluÅŸturulmasÄ±nÄ± saÄŸlar. Bu sayede nesnenin 
            kopyalanmasÄ±nÄ± yada yeni bir tane oluÅŸturmasÄ±nÄ± engeller ve nesneye ihtiyaÃ§ 
            duyulduÄŸunda o nesnenin daha Ã¶nceden oluÅŸturulan Ã¶rneÄŸi Ã§aÄŸÄ±rÄ±r. VeritabanÄ± 
            baÄŸlantÄ±larÄ±nda, port baÄŸlantÄ±larÄ±nda, yada dosya iÅŸlemleri gibi tek bir 
            nesneye ihtiyaÃ§ duyduÄŸumuz zamanlarda kullanÄ±rÄ±z.
            
            -----------------------------------------------------------------------------
            
            Solid prensipleri nedir?
            
            Bir metot veya bir class ne amaÃ§ ile yazÄ±lÄ±yorsa iÃ§erikte o amaÃ§ ile ilgili 
            kodlarÄ±n olmasÄ± gerektiÄŸi prensip.
            
            -----------------------------------------------------------------------------
            
            Abstrack class ile interface arasÄ±nda fark nedir?
            
            Interfaceâ€™lerin bÃ¼tÃ¼n metotlarÄ± implement etmek zorunludur
            Abstrack classlarda sadece abstrack metotlar implement etmek zorunludur.
            Interfaceâ€™lerde can-do iliÅŸkisi vardÄ±r.
            Abstrack classlarda is-a iliÅŸkisi vardÄ±r.
            Bir sÄ±nÄ±f sadece bir abstrack classÄ± inherit edebilir.
            Bir sÄ±nÄ±f birden Ã§ok interfaceâ€™i inherit edebilir
            
            -----------------------------------------------------------------------------
            
            Application nedir?
            
            Application classâ€™Ä± Androidâ€™in temeli olarak gÃ¶rÃ¼lebilir. Androidâ€™in 
            gerÃ§ekleÅŸtirdiÄŸi diÄŸer eylem ve hizmetlerin tÃ¼m bilgilerini barÄ±ndÄ±ran ana 
            classâ€™dÄ±r. Program Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda Androidâ€™de her ÅŸeyden Ã¶nce ilk bu 
            class baÅŸlatÄ±lÄ±r.
            
            -----------------------------------------------------------------------------
            
            Androidâ€™in GUIâ€™sÄ±nÄ±n depolandÄ±ÄŸÄ± yere ne ad verilir?
            
            Androidâ€™in GUIâ€™sÄ± â€œAndroid SDKâ€ adlÄ± bir yerde depolanÄ±r. Ne olduÄŸunu ÅŸÃ¶yle 
            bir Ã¶rnekle aÃ§Ä±klayalÄ±m. BahÃ§eye gitmeyi ve orada Ã§alÄ±ÅŸmayÄ± planladÄ±ÄŸÄ±nÄ±zÄ± 
            hayal edin. Neye ihtiyaÃ§ duyarsÄ±nÄ±z? AraÃ§lara aletlere. AraÃ§lar nerede 
            saklanÄ±r? Ã‡oÄŸunlukla bir kulÃ¼bede. Android SDK da bu kulÃ¼be gibidir. 
            GeliÅŸtiricinin kolay eriÅŸimi iÃ§in tÃ¼m gerekli ve Ã¶nemli araÃ§larÄ± iÃ§erisinde 
            depolar.
            
            -----------------------------------------------------------------------------
            
            Implicit ve explicit intentâ€™leri aÃ§Ä±klayÄ±n.
            
            Implicit intent (Ã¼stÃ¼ kapalÄ±) kullanÄ±ldÄ±ÄŸÄ±nda Android arayÃ¼zÃ¼ iÅŸleminizi 
            gerÃ§ekleÅŸtirmeye yardÄ±mcÄ± olabilecek ayarlar iÃ§in sistemi kontrol eder. Explicit intent (aÃ§Ä±k) ise iÅŸlem gerÃ§ekleÅŸtirilirken sisteminizin kullanmasÄ± gereken bileÅŸenleri belirtirsiniz. BasitleÅŸtirmek gerekirse sisteminize ne yapacaÄŸÄ±nÄ± sÃ¶yler ve esnekliÄŸe yer bÄ±rakmazsÄ±nÄ±z.
            
            -----------------------------------------------------------------------------
            
            Android hangi bytecodeâ€™u kullanÄ±r?
            -dalvik.
            
            Android sisteminde adapterâ€™lar, AdapterViewâ€™Ä± 
            (kullanÄ±ldÄ±ÄŸÄ± belli senaryolara gÃ¶re ne olduÄŸu deÄŸiÅŸir) harici bir veri 
            kaynaÄŸÄ±yla baÄŸlamak iÃ§in kullanÄ±lÄ±r.
            
            -----------------------------------------------------------------------------
            
            Soru 10: â€œAsyncTaskâ€ ve â€œThreadâ€ arasÄ±ndaki fark nedir?
            AsyncTaskâ€™ler kÄ±sa sÃ¼reli iÅŸlemlerle (en fazla 5 saniye) Ã§alÄ±ÅŸmak iÃ§in 
            kullanÄ±lÄ±r. Threadâ€™ler daha uzun iÅŸlemler iÃ§indir.
            
            -----------------------------------------------------------------------------
            
            
            Android Design Patterns:
            
            1. Singleton--------------------------------
            
            
            -kotlinde;
            
            object Singleton {
            
                fun doSomething(){
            
                }
            
            }
            
            -javada;
            
            public final class Singleton{
             @NotNull
            public static final Singleton INSTANCE; //singleton olacaÄŸÄ± iÃ§in static olur.
            
               public final void doSomething() {
               }
            
               private Singleton() {
               }
            
               static {
                  Singleton var0 = new Singleton(); //singleton olduÄŸu iÃ§in hep 1 tane 
                  INSTANCE = var0;                  //instance oluÅŸturacak.  
               }
            
            
            }
            
            
            2. Factory Pattern ---------------------------------
            
            benzer(aynÄ±) type'lardaki nesnelerin hangisinin create edileceÄŸini ayÄ±rt 
            etmeye Ã§alÄ±ÅŸÄ±r.
            
            yani farklÄ± nesneler oluÅŸturduk ama tipleri aynÄ±, hangisin seÃ§ileceÄŸine karar
            veriliyor.
            
            
            
            
            3. Builder Pattern ---------------------------------
            
            
            
            
            4. Facade Pattern ---------------------------------
            
            
            
            Dependency Injection Pattern? ---------------------------------
            
            
            
            5. Adapter Pattern ---------------------------------
            
            
            6. Abstract Factory Pattern---------------------------------
            
            
            -----------------------------------------------------------------------------
            
            anti patterns
            
            
            
            
            ------------------------------------MVVM------------------------------------
            
            Model - View - ViewModel.
            Data Source - UI - Business Logic.
            
            Repository,ViewModel ve View'dan oluÅŸur.ViewModel,Repo'ya request data(istek) 
            atar. Repo'dan dÃ¶nen datalar(return data) ViewModela ulaÅŸÄ±r. Business 
            logic iÅŸlemleri ViewModel'da gerÃ§ekleÅŸir. en son sonuÃ§lar ViewModel'dan 
            View'a aktarÄ±lÄ±r ve View'da sadece gÃ¶rÃ¼nÃ¼mleri baÄŸlama logic'i olur, 
            business logic deÄŸil.
            
            Not: ViewModel kiminle iletiÅŸim halinde olduÄŸundan haberdar olmamalÄ±dÄ±r.
            
            
            --------------------------------------------------------------
            
            HashSet, yinelenen deÄŸerlere izin vermez. HashMap, anahtar, 
            deÄŸer Ã§iftlerini saklar ve yinelenen anahtarlara izin vermez. 
            Anahtar yineleniyorsa, eski anahtar yeni deÄŸerle deÄŸiÅŸtirilir.
            </p>




							</section>

					</div>


					


				<!-- Footer -->
				<footer id="footer">
					<section>
						<form action="https://formsubmit.co/b08daa73efb0824c10de3457bce379a3" method="POST">  <!-- mail iÃ§in backend servis-->
							<div class="fields">
								<div class="field">
									<label for="name">Name</label>
									<input type="text" name="name" id="name" required/>
								</div>
								<div class="field">
									<label for="email" style="color:rgb(230, 17, 17)" >Email *</label>
									<input pattern='^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$' type="email" name="email" id="email" required/>
								</div>
								<div class="field">
									<label for="message">Message</label>
									<textarea name="message" id="message" rows="3" required></textarea>
								</div>
							</div>
							<ul class="actions">
								<li><input type="submit" value="Send Message" /></li>
							</ul>
						</form>
					</section>
					<section class="split contact">
						<section class="alt">
							<h3>Address</h3>
							<p>Kocaeli/Turkey(TÃ¼rkiye)<br />
							  Ä°stanbul/Turkey(TÃ¼rkiye)</p>
						</section>
						<section>
							<h3>Phone</h3>
							<p><a href="tel:0507-999-6604">(0507) 999-6604</a></p>
						</section>
						<section>
							<h3>Email</h3>
							<p><a href="mailto: atilla734@gmail.com">atilla734@gmail.com</a></p>
						</section>
						<section>
							<h3>Social</h3>
							<ul class="icons alt">
<!-- 			<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
							<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>  -->
							<li><a href="https://www.linkedin.com/in/atilla-aydemir" target="_blank" class="icon brands fa-linkedin"><span class="label">Linkedin</span></a></li>
							<li><a href="https://github.com/aliatillaydemir" target="_blank" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
							</ul>
						</section>
					</section>
				</footer>

			<!-- Copyright -->
				<div id="copyright">
					<ul><li>&copy; AttiTech</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li></ul>
				</div>

		</div>

	<!-- Scripts -->
		<script src="/assets/js/jquery.min.js"></script>
		<script src="/assets/js/jquery.scrollex.min.js"></script>
		<script src="/assets/js/jquery.scrolly.min.js"></script>
		<script src="/assets/js/browser.min.js"></script>
		<script src="/assets/js/breakpoints.min.js"></script>
		<script src="/assets/js/util.js"></script>
		<script src="/assets/js/main.js"></script>

</body>
</html>